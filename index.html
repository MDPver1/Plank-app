<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Plank Timer</title><style>
:root{--bg:#0b0b0b;--fg:#fff;--muted:#999;--ring:#1a1a1a;--btn-size:82px;--ring-w:14px}
*{box-sizing:border-box}html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif}
.app{height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:24px}
.row{display:flex;align-items:center;gap:28px}
#value{font-weight:800;font-size:96px;letter-spacing:2px;text-align:center}
.round{width:var(--btn-size);height:var(--btn-size);border-radius:999px;border:2px solid #fff;display:flex;align-items:center;justify-content:center;background:transparent;color:#fff;font-size:36px;line-height:1;user-select:none}
.round:active{opacity:.8}
.cta{min-width:var(--btn-size);height:var(--btn-size);border-radius:999px;border:2px solid #fff;display:flex;align-items:center;justify-content:center;padding:0 26px;font-weight:700}
#startBtn{background:#0a84ff;color:#fff}
#stopBtn{background:#ff3b30;color:#fff}
#againBtn{background:#14b8a6;color:#fff}
.hidden{display:none}
.canvasWrap{position:relative;width:100%;max-width:520px;aspect-ratio:1}
#ring{width:100%;height:100%;display:block}
.centerNum{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:112px}
#overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:var(--bg);z-index:10}
#overlayText{font-size:72px;font-weight:900}
@media (max-width:380px){#value{font-size:84px}.centerNum{font-size:96px}}
</style></head><body>
<div id="overlay"><div id="overlayText">Ready</div></div>

<div class="app" id="screenSetup">
  <div class="row">
    <button class="round" id="minus">−</button>
    <div id="value">30</div>
    <button class="round" id="plus">+</button>
  </div>
  <button class="cta" id="startBtn">Start</button>
</div>

<div class="app hidden" id="screenRun">
  <div class="canvasWrap">
    <canvas id="ring"></canvas>
    <div class="centerNum" id="centerNum">30</div>
  </div>
  <button class="cta" id="stopBtn">Stop</button>
</div>

<div class="app hidden" id="screenDone">
  <div class="canvasWrap" style="opacity:0;pointer-events:none"><canvas></canvas></div>
  <div class="centerNum" style="position:static;font-size:72px">Well done!</div>
  <button class="cta" id="againBtn">Again</button>
</div>

<script>
(()=>{"use strict";
let total=30, left=30, running=false, tickInt=null, drawInt=null, startTs=0;
const v=q("value"), minus=q("minus"), plus=q("plus"),
      sSetup=q("screenSetup"), sRun=q("screenRun"), sDone=q("screenDone"),
      startBtn=q("startBtn"), stopBtn=q("stopBtn"), againBtn=q("againBtn"),
      centerNum=q("centerNum"), cv=q("ring"), overlay=q("overlay"), ovTxt=q("overlayText");
function q(id){return document.getElementById(id)}
function fmt(n){return n.toString()}
function clamp(n,min,max){return Math.max(min,Math.min(max,n))}
function setTotal(n){total=clamp(n,10,999); v.textContent=fmt(total)}
minus.onclick=()=>setTotal(total-10);
plus.onclick=()=>setTotal(total+10);

function beep(ms=150,f=880,v=0.06){try{
 const AC=window.AudioContext||window.webkitAudioContext; const ac=new AC();
 const o=ac.createOscillator(), g=ac.createGain(); o.frequency.value=f; g.gain.value=v;
 o.connect(g); g.connect(ac.destination); o.start(); o.stop(ac.currentTime+ms/1000);
 setTimeout(()=>ac.close(),ms+60);}catch(e){}}

async function awake(){try{ if('wakeLock' in navigator){window._wl=await navigator.wakeLock.request('screen')} }catch(e){}}

function show(el){sSetup.classList.add("hidden");sRun.classList.add("hidden");sDone.classList.add("hidden");el.classList.remove("hidden")}
function countBeepIfNeeded(){
 const passed = total-left;
 if(passed>0 && passed%10===0) beep(150,880,0.06);
}

function drawRing(){
 const d = Math.min(cv.clientWidth, cv.clientHeight);
 cv.width=d; cv.height=d;
 const ctx=cv.getContext("2d");
 const cx=d/2, cy=d/2, r = d/2-28; // отступ, чтобы кнопки и кольцо не соприкасались
 const w = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ring-w'))||14;

 ctx.clearRect(0,0,d,d);

 // базовый серый тонкий след (еле заметный)
 ctx.lineWidth=w; ctx.lineCap="round";
 // НЕ рисуем базовый след по условию «после завершения не виден»

 // оставшееся кольцо: начинаем с максимума красного (слева, π) и идём по часовой
 // прогресс 0..1
 const f = clamp((Date.now()-startTs)/1000/total,0,1);
 const remain = 1 - f; if(remain<=0){return;} // ничего не рисуем в конце

 const startA = Math.PI; // 180° (лево)
 const span = Math.PI*2*remain;
 const endA = startA + span;

 // рисуем по частям, чтобы цвета разделялись жёстко ровно сверху (−90°, = -π/2)
 const split = -Math.PI/2; // верх
 // вспомогательная функция сегмента
 function arcSeg(a1,a2,color){
   const norm=(a)=>a; // углы уже в радианах
   const aa1=norm(a1), aa2=norm(a2);
   if(aa2<=aa1) return;
   ctx.beginPath(); ctx.strokeStyle=color; ctx.arc(cx,cy,r,aa1,aa2,false); ctx.stroke();
 }
 // вычленим видимый интервал [startA, endA]
 // он может переходить через split или нет. разобьём на куски по полукругам:
 const R1=[Math.PI/2, 3*Math.PI/2]; // левая половина (красная) от 90° до 270°
 const R2=[-Math.PI/2, Math.PI/2];  // правая половина (зелёная) от -90° до 90°
 // нормализуем в возрастающую последовательность
 let a1=startA, a2=endA;
 if(a2> startA+Math.PI*2) a2=startA+Math.PI*2;

 // функция пересечения отрезков по углам в диапазоне [base, base+2π)
 function drawPart(a1,a2,range,color){
   const [r1,r2]=range;
   const s=Math.max(a1,r1), e=Math.min(a2,r2);
   if(e>s+1e-4) arcSeg(s,e,color);
 }

 // рисуем отдельно пересечение с «красной» половиной и «зелёной»
 drawPart(a1,a2,R1,"#ff453a");
 drawPart(a1,a2,R2,"#34c759");
}

function startCountdownOverlay(cb){
 overlay.style.display="flex";
 const words=["Ready!","Set!","Go!"];
 let i=0; ovTxt.textContent=words[i];
 const t=setInterval(()=>{ i++; if(i<words.length){ ovTxt.textContent=words[i]; }
   else{ clearInterval(t); overlay.style.display="none"; cb(); }
 },1000);
}

function run(){
 running=true; left=total; centerNum.textContent=fmt(left);
 show(sRun); awake();
 startTs=Date.now();
 // визуалка
 drawInt=setInterval(drawRing,33);
 // тики
 tickInt=setInterval(()=>{
   left--; centerNum.textContent=fmt(left);
   countBeepIfNeeded();
   if(left<=0){ clearInterval(tickInt); clearInterval(drawInt);
     // тройной бип
     beep(160,880,0.06); setTimeout(()=>beep(160,880,0.06),220); setTimeout(()=>beep(160,880,0.06),440);
     show(sDone);
   }
 },1000);
}

startBtn.onclick=async()=>{
  // iOS аудио разблокируется кликом
  startCountdownOverlay(()=>run());
};
stopBtn.onclick=()=>reset();
againBtn.onclick=()=>reset();

function reset(){
  running=false;
  clearInterval(tickInt); clearInterval(drawInt);
  setTotal(total); // вернуть отображение
  show(sSetup);
}

setTotal(30);
})();
</script>
</body></html>
